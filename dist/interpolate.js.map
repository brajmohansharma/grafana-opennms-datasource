{"version":3,"sources":["../src/interpolate.js"],"names":[],"mappings":"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","file":"interpolate.js","sourcesContent":["import _ from 'lodash';\n\nfunction cartesianProductOfArrays(arrays) {\n  // Based on the code from http://stackoverflow.com/questions/15298912/\n  // javascript-generating-combinations-from-n-arrays-with-m-elements\n  var r = [], max = arrays.length - 1;\n\n  function helper(arr, i) {\n    for (var j = 0, l = arrays[i].length; j < l; j++) {\n      var a = arr.slice(0); // clone arr\n      a.push(arrays[i][j]);\n      if (i === max) {\n        r.push(a);\n      } else {\n        helper(a, i + 1);\n      }\n    }\n  }\n\n  helper([], 0);\n  return r;\n}\n\nfunction cartesianProductOfVariables(variables) {\n  // Collect the values from all of the variables\n  var allValues = [];\n  _.each(variables, function (variable) {\n    allValues.push(variable.value);\n  });\n\n  // Generate the cartesian product\n  var productOfAllValues = cartesianProductOfArrays(allValues);\n\n  // Rebuild the variables\n  var productOfAllVariables = [];\n  _.each(productOfAllValues, function (rowOfValues) {\n    var rowOfVariables = [];\n    for (var i = 0, l = variables.length; i < l; i++) {\n      // Deep clone\n      var variable = JSON.parse(JSON.stringify(variables[i]));\n      variable.value = rowOfValues[i];\n      rowOfVariables.push(variable);\n    }\n    productOfAllVariables.push(rowOfVariables);\n  });\n\n  return productOfAllVariables;\n}\n\nfunction defaultContainsVariable(value, variableName) {\n  if (_.isNull(value) || _.isEmpty(value)) {\n    return false;\n  }\n  return value.indexOf(\"$\" + variableName) >= 0;\n}\n\nfunction defaultReplace(value, variables) {\n  if (_.isNull(value) || _.isEmpty(value)) {\n    return value;\n  }\n  var interpolatedValue = value;\n  _.each(variables, function (variable) {\n    interpolatedValue = interpolatedValue.replace(\"$\" + variable.name, variable.value);\n  });\n  return interpolatedValue;\n}\n\n/**\n * Replaces the object's attributes with the values of the referenced variables.\n *\n * If a referenced variable contains multiple values or if there are multiple referenced variables\n * then we generate copies of the object with all of the possible permutations.\n *\n * See interpolate_spec.js for examples.\n *\n * @param object\n *    the object to interpolate\n * @param attributes\n *    a list of attributes on a given object that should be checked for variables\n * @param variables\n *    a list of variables of the form [{name: 'varname', value: ['value1', 'value2']}, ...]\n * @param callback\n *    an optional callback made with the object after variable substitution has been performed\n * @param containsVariable\n *    optionally override the function used to determine if a string contains a reference to the named variable\n * @param replace\n *    optionally override the function used to substitute the variable reference in a string with the variables's value\n * @returns an array of objects, if no substitutions were performed, the array will contain the original object\n */\nexport function interpolate(object, attributes, variables, callback, containsVariable, replace) {\n  // Use default for the functions when undefined\n  if (callback === undefined) {\n    callback = () => {};\n  }\n  if (containsVariable === undefined) {\n    containsVariable = defaultContainsVariable;\n  }\n  if (replace === undefined) {\n    replace = defaultReplace;\n  }\n\n  // Add the index variable with a single value\n  var variablesWithIndex = _.clone(variables);\n  variablesWithIndex.push({name: 'index', value: [0]});\n\n  // Collect the list of variables that are referenced by one or more of the keys\n  var referencedVariables = [];\n  _.each(variablesWithIndex, function (variable) {\n    var isVariableReferenced = _.find(attributes, function (attribute) {\n      return containsVariable(object[attribute], variable.name);\n    });\n\n    if (isVariableReferenced) {\n      referencedVariables.push(variable);\n    }\n  });\n\n  if (referencedVariables.length < 1) {\n    // No variables are referenced, nothing to substitute\n    callback(object);\n    return [object];\n  }\n\n  // Generate all possible permutations of the referenced variable's values\n  var productOfAllVariables = cartesianProductOfVariables(referencedVariables);\n\n  // Perform the required variable substitution\n  var objects = [];\n  var index = 0;\n  _.each(productOfAllVariables, function (rowOfReferencedVariables) {\n    // Update the value of the index variable to reflect the index of the row\n    _.each(rowOfReferencedVariables, function (variable) {\n      if (variable.name === 'index') {\n        variable.value = 'idx' + index;\n        index += 1;\n      }\n    });\n\n    var o = _.clone(object);\n    _.each(attributes, function (attribute) {\n      o[attribute] = replace(o[attribute], rowOfReferencedVariables);\n    });\n\n    callback(o);\n\n    objects.push(o);\n  });\n\n  return objects;\n}\n"]}